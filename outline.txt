Intro
-----
Imagine you're working on a project with a bunch of people. Code is constantly changing,
things get overwritten, defects and regressions are introduced, etc. Hard to imagine, 
right? 

Someone has the bright idea that we should have a database in which we record all
changes: what changed, when, why, and by whom.


Say you're working on a team in which several people need to edit the same CSS and JS
files. That works fine while as long as the team is smaller than two people. But as the
team grows, it gets harder not to overwrite each others changes.

So the team decides to institute some ground rules. A change log is added to the top of
the file. 

Why do we even need source control? Why can't we just put a change log at the top of
the file? 

As Ilya (?) pointed out, many if not most changes involve more than one file. So we 
would really want our change log to be a separate file that notes what files change,
who changed them, when, and why. In fact, we should take that file, copy it to a 
directory that also contains copies of the changed files, zip it up, and email it
out to the whole team.

Each team member, when he gets a chance, can unzip and copy each of the new files to
his local copy of the code.



Each commit knows:

- Who changed the code
- What files changed
- Where the previous/parent commit is
- When the changes were committed
- Why (commit message)

git config (name and email)
TextMate bundle
TextMate integration
BASH prompt
git init
git add 
git status
git mv
git rm
git diff
git stash
git stash apply
git commit
git commit --amend
git log
git log filename
git log revision
git log since="2 days"
git show revision
git blame
git checkout revision
git checkout -b
git branch
git rebase -i
git rebase
git merge
git branch -d
git tag
git help

https://github.com/AlexZeitler/gitcheatsheet


= blank rectangle

- git init

- "initialized empty repository..."

= house 
- (create a file called house.css)

- git status
- ? house.css
! Talk about staging area.

- git add house.css

- 1 files changed, 2 insertions(+)

- git commit -m "First commit. The house has walls."

- (output of first commit)

! Now let's add a roof.
= roof 
- (write code for the roof)

! Check the status
- git status
- # modified: house.css, etc.
! We need to add the file to the staging area.

- git add house.css

- 1 files changed, 28 insertions(+), 2 deltions (-)

- git commit -m "Added a roof"

- (output of commmit)

! Now let's add a door to the house. 
= door
- (create door.css, edit house.css to @import door.css)

! We can add all file and commit at the same time
- git commit -a -m "Added a door"

- (output of commit)
 
! So now we have three commits. Each commit has a unique ID. We can see what changed
! using git log.
- git log 

- commit 01262438d7407ac62156a74e7e714596be53b132
- Author: Patrick McElhaney <patrick.mcelhaney@ally.com>
- Date:   Wed Mar 9 10:58:50 2011 -0500
- 
-   Adjusted size of the box to be just big enough to frame the houses.
-
- commit 6e3500e16e100c952aec9d2701ff51bd4919666e
- Author: Patrick McElhaney <patrick.mcelhaney@ally.com>
- Date:   Wed Mar 9 10:56:26 2011 -0500
-
-    Add a roof.
-
- commit 6257eb4b17ac63153e3e6bccb1c43107dbea9e19
- Author: Patrick McElhaney <patrick.mcelhaney@ally.com>
- Date:   Wed Mar 9 10:51:20 2011 -0500
-   
-    First commit. The house has walls.

! By the way, when you start, you're always on the default branch, called "master"
= master

! We switch to a new branch.
= my-branch
- git checkout -b my-branch
- Switched to a new branch 'my-branch'

! Now let's add some code on this branch and commit it.
- git commit -a -m "Added a window"

! Let's give it some color.
- git commit -a 

! What did I do wrong? I forgot the commit message.
! If you don't type a commit message, an editor will pop up so you can type it.
- (screenshot of TextMate)

! When you're done, just close the editor.
- (output of commit)

! One last commit on this branch
= chimney
- git commit -a -m "I've always wanted a real fireplace."
- result of git commit

! Now let's check out the master branch again.
- git checkout master
- (output of checkout)

! We need to add vinyl siding.
= siding
- git commit -a -m "Added siding"
- output of commit

! Actually, make that brick
= brick
- git commit -a -m "Changed siding to brick"
- output of commit

! Now, if we look at the log, we'll only see changes that are on master
- git log
- (ouptut of log)

! We're ready to land the window, etc., on the master branch. To do that,
! we'll first switch back to the branch.
- git checkout my-branch
- (output of git checkout branch)

! Now, we rebase the branch onto master. That means we take all of these
! changes and pretend like they happened after the last change on master.
= move arrow to point back
- git rebase master

= change so that bricks are pushed into the new branch
- (output of git rebase)

! Now all of the commits are in one continuous line. We can merge onto 
! master and it will be a fast-forward merge. That's a good thing!
! First we check out master.
- git checkout master
- (output of master)

! Then we merge my-branch onto master
- git merge my-branch
- (output of merge)
= changes copied up into master

! Now we can delete the branch
- git branch -d my-branch

= branch is removed
- (output of delete)

! Some more things I didn't cover:
! - show
! - git checkout <commit>
! - git checkout HEAD^ 
! - git checkout HEAD~1
! - git log HEAD~5
! - git log origin/master
! - git log since="2 days"
! - git log HEAD~20..HEAD^^
! - git blame
! - git blame | mate
! - git tag
! - git rebase -i
! - git stash
! - git stash apply
! - git show <revision>
! - git help













